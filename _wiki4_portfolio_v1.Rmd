---
title: "Wikifolio 4 Portfolio"
output: html_document
---

#THIS PART MIGHT GO TO quantTrading_P4_wiki

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(dplyr)
library(quantmod)
library(matrixStats)
library(data.table)
library(cluster)
library(PerformanceAnalytics)
library(stockPortfolio)
library(FRAPO)
library(quadprog)
library(corpcor)
library(ggplot2)

setwd("/Users/home/Documents/Finanzen/R.investment/portfolio/wiki4_dach")
options("getSymbols.warning4.0"=FALSE)


```

```{r}

eff.frontier <- function (returns, short="no", max.allocation=NULL, risk.premium.up=.5, risk.increment=.005){
     # return argument should be a m x n matrix with one column per security
     # short argument is whether short-selling is allowed; default is no (short selling prohibited)
     # max.allocation is the maximum % allowed for any one security (reduces concentration)
     # risk.premium.up is the upper limit of the risk premium modeled (see for loop below)
     # risk.increment is the increment (by) value used in the for loop
     
     require(corpcor) 
     require(quadprog)
     
     covariance <- make.positive.definite(cov(returns))
     print(covariance)
     n <- ncol(covariance)
      
     # Create initial Amat and bvec assuming only equality constraint (short-selling is allowed, no allocation constraints)
     Amat <- matrix (1, nrow=n)
     bvec <- 1
     meq <- 1
      
     # Then modify the Amat and bvec if short-selling is prohibited
     if(short=="no") {
          Amat <- cbind(1, diag(n))
          bvec <- c(bvec, rep(0, n))
     }
      
     # And modify Amat and bvec if a max allocation (concentration) is specified
     if(!is.null(max.allocation)) { 
          if(max.allocation > 1 | max.allocation <0){
          stop("max.allocation must be greater than 0 and less than 1")
          }
          if(max.allocation * n < 1) {
          stop("Need to set max.allocation higher; not enough assets to add to 1")
          }
          Amat <- cbind(Amat, -diag(n))
          bvec <- c(bvec, rep(-max.allocation, n))
     }
      
     # Calculate the number of loops based on how high to vary the risk premium and by what increment
     loops <- risk.premium.up / risk.increment + 1
     loop <- 1
      
     # Initialize a matrix to contain allocation and statistics
     # This is not necessary, but speeds up processing and uses less memory
     eff <- matrix(nrow=loops, ncol=n+3)
     # Now I need to give the matrix column names
     colnames(eff) <- c(colnames(returns), "Std.Dev", "Exp.Return", "sharpe")
      
     # Loop through the quadratic program solver
     for (i in seq(from=0, to=risk.premium.up, by=risk.increment))  {
          dvec <- colMeans(returns) * i # This moves the solution up along the efficient frontier
          sol <- solve.QP(covariance, dvec=dvec, Amat=Amat, bvec=bvec, meq=meq)
          eff[loop,"Std.Dev"] <- sqrt(sum(sol$solution *colSums((covariance * sol$solution))))
          eff[loop,"Exp.Return"] <- as.numeric(sol$solution %*% colMeans(returns))
          eff[loop,"sharpe"] <- eff[loop,"Exp.Return"] / eff[loop,"Std.Dev"]
          eff[loop,1:n] <- sol$solution
          loop <- loop+1
          }
      
     return(as.data.frame(eff))
}

```




###Calculating portfolio composition

```{r, echo=FALSE, warning=FALSE, message=FALSE}

data_w4 <- read.csv("/Users/home/Documents/Finanzen/R.investment/portfolio/wiki4_dach/20160127_wiki4.csv", 
                     sep=",", header=T, strip.white=T, na.strings = c("NA", ""),
                     colClasses = c("character", "character", "numeric", "integer", "numeric", "numeric", "numeric", "integer",
                                    "integer")
                     )
data_w4 <- data_w4[, -which(names(data_w4) %in% 
                                   c("Performance", "Monate"))]


#calculate clusters
data_w4clst <- data_w4[, c("Perf_pm", "Drawdown", "SharpeRatio", "Qualitaetsmerkmale")]
data_w4clst <- data_w4clst %>%
               transmute(Perf_pm=scale(Perf_pm) , Drawdown=scale(Drawdown) , SharpeRatio=scale(SharpeRatio),
                         Qualitaetsmerkmale=scale(Qualitaetsmerkmale))


set.seed(1235)
groups_w4 <- pam(data_w4clst, k=30, metric = "manhattan")
data_w4$groups <- groups_w4$clustering 
table(data_w4$groups)
#remove bad clusters manually
data_w4_select <- data_w4 %>%
                dplyr::filter(groups %in% c(1,3,12,8,20,19,6,30,11,7,5,10,13,27,5,18,29,9,7,2,4,5,6,24) & Aktivitaet == 1 )

#re-calculate clusters
data_w4clst <- data_w4_select[, c("Perf_pm", "Drawdown", "SharpeRatio", "Qualitaetsmerkmale")]
data_w4clst <- data_w4clst %>%
               transmute(Perf_pm=scale(Perf_pm) , Drawdown=scale(Drawdown) , SharpeRatio=scale(SharpeRatio),
                         Qualitaetsmerkmale=scale(Qualitaetsmerkmale))

set.seed(1235)
groups_w4 <- pam(data_w4clst, k=5, metric = "manhattan")
data_w4_select$groups <- groups_w4$clustering 
table(data_w4_select$groups)


###

data_w4_price <- read.csv("/Users/home/Documents/Finanzen/R.investment/portfolio/wiki4_dach/20160127_wiki4_price.csv", 
                     sep=",", header=T, strip.white=T, na.strings = c("NA", ""))
                     
data_w4_price$Datum <- as.Date(data_w4_price$Datum, format="%d.%m.%Y")
data_w4_price <- as.xts(data_w4_price[,-1], order.by = data_w4_price$Datum)
data_w4_return <- ROC(data_w4_price, n=5, type = "discrete")[-c(1:5),]

#efficient frontier
eff <- eff.frontier(returns=data_w4_return, short="no", max.allocation=0.4, risk.premium.up=.5, risk.increment=.001)

#point for optimal sharpe
eff.optimal.point <- eff[eff$sharpe==max(eff$sharpe),]
t(round( eff[eff$sharpe==max(eff$sharpe),], 2))


#point between optimal sharpe and maximum return = eff.optimal.return
opt.return <- (0.5*( eff[eff$sharpe==max(eff$sharpe),]$'Exp.Return' +     #return at max. sharpe
               eff[eff$'Exp.Return'==max(eff$'Exp.Return'),]$'Exp.Return' ) )  #return at max. return

eff.optimal.return <- head( eff[eff$'Exp.Return' >= opt.return, ], 1)
t(round(eff.optimal.return, 2))


#point between optimal sharpe and the optimal sharpe/max return

eff.opt.return.med <- tail( eff[eff$sharpe>=(0.5*(eff.optimal.return$sharpe + eff.optimal.point$sharpe)), ], 1)
t(round(eff.opt.return.med, 2))




#max drawdown limited portfolio
maxdd_05 <- t(round(PMaxDD(data_w4_price, MaxDD = 0.055, softBudget = TRUE)@weights, 2))

x <- Return.portfolio(data_w4_return, weights = as.vector(maxdd_05))
charts.PerformanceSummary(x)




opt.point <- t(round( eff[eff$sharpe==max(eff$sharpe),], 2))
opt.point <- head(opt.point, -3)
y <- Return.portfolio(data_w4_return, weights = as.vector(opt.point))
charts.PerformanceSummary(y)


opt.return <- t(round(eff.optimal.return, 2))
opt.return <- head(opt.return, -3)
z <- Return.portfolio(data_w4_return, weights = as.vector(opt.return))
charts.PerformanceSummary(z)

opt.return.med <- t(round(eff.opt.return.med, 2))
opt.return.med <- head(opt.return.med, -3)
w <- Return.portfolio(data_w4_return, weights = as.vector(opt.return.med))
charts.PerformanceSummary(w)


cbind(t(maxdd_05), opt.return.med, opt.point) 

charts.PerformanceSummary(data_w4_return$DE000LS9HFZ6)




# #points between eff.optimal.point and max.return          
# 
# sharpe_seq <- seq(from=eff[eff$'Exp.Return'==max(eff$'Exp.Return'),]$sharpe, 
#                   to=eff[eff$sharpe==max(eff$sharpe),]$sharpe, by=0.01)
# s=1; eff.sequence_lst <- list()
# while (s <= length(sharpe_seq)) {
#      
#      eff.sequence <- tail( eff[eff$sharpe>=sharpe_seq[s] & eff$sharpe<=0.6,], 1)
#      tmp1 <- t(round(eff.sequence,2))
#      tmp1 <- as.vector(tmp1[1:(nrow(tmp1)-3)])
#      eff.sequence$maxDD <- maxDrawdown(data_w4_return, weights = tmp1, invert=TRUE)/2.77
#      eff.sequence_lst[[s]] <- eff.sequence
# 
#      s=s+1
# }
#      
# eff.high.return <-  do.call(rbind.data.frame, eff.sequence_lst)
# plot(y=eff.high.return$Exp.Return, x=eff.high.return$maxDD)
# 
# #-0.56 = -0.21 // -0.46 = -0.16    >factor 2.77
# eff.high.return[eff.high.return$maxDD >= -10.5, ]



               
# Color Scheme
 ealred  <- "#7D110C"
 ealtan  <- "#CDC4B6"
 eallighttan <- "#F7F6F0"
 ealdark  <- "#423C30"
 
 #plot: efficient frontier with eff.optimal.return point
ggplot(eff, aes(x=Std.Dev, y=Exp.Return)) + geom_point(alpha=.1, color=ealdark) +
 geom_point(data=eff.optimal.return, aes(x=Std.Dev, y=Exp.Return, label=sharpe), color=ealred, size=5) +
 annotate(geom="text", x=eff.optimal.return$Std.Dev, y=eff.optimal.return$Exp.Return,
 label=paste("Risk: ", round(eff.optimal.return$Std.Dev*100, digits=3),"\nReturn: ",
 round(eff.optimal.return$Exp.Return*100, digits=4),"%\nSharpe: ",
 round(eff.optimal.return$sharpe*100, digits=2), "%", sep=""), hjust=0, vjust=1.2) +
 ggtitle("Efficient Frontier\nand Optimal Portfolio") + labs(x="Risk (standard deviation of portfolio variance)", y="Return") +
 theme(panel.background=element_rect(fill=eallighttan), text=element_text(color=ealdark),
 plot.title=element_text(size=24, color=ealred))





etfs <- c("5X61.DE", "X504.DE", "X505.DE", "X507.DE", "DBXM.DE", "EXX6.DE", "X508.DE", "5X60.DE")






########################
########################



write.csv(data_scrn, file = paste(Sys.Date(), "_", "data_scrn.csv", sep=""))     

#save portfolio
write.csv(info_tbl2, file = paste(Sys.Date(), "_", "wiki2_portfolio.csv", sep=""))    



```



